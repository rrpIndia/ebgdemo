<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- ================= PAGE LAYOUT CSS ================= -->
<style>
body {
  margin: 0;
}

.hd {
  filter: drop-shadow(2px 3px 2px rgb(0 0 0 / 0.4));
}

.evm {
  display: flex;
  flex-direction: column; /* mobile */
  align-items: center;
  gap: 16px;
}

.svg-vvpat-wrapper {
  margin-top: 24px;
  display: flex;
  justify-content: center;
}

.svg-vvpat {
  width: 320px;
  max-width: 90vw;
  /*outline:2px solid lime;*/
}

.svg-ballot-unit-wrapper {
  display: flex;
  justify-content: center;
}

.svg-ballot-unit {
  /*outline:2px solid lime;*/
  max-width: 95vw;
  width: 320px;
}

.wire-layer {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
  opacity: 0;
}

#wire {
  fill: none;
  stroke: #f4c400;
  stroke-width: 8;
  stroke-linecap: round;
}
</style>
</head>

<body>

<div class="evm">

<!-- ================= WIRE ================= -->
<svg class="wire-layer" viewBox="0 0 400 600">
  <path id="wire"
    d="M 310 180
       C 310 180, 350 180, 355 180
       C 360 210, 360 240, 355 260
       C 330 270, 260 250, 200 260
       L 200 318"/>
</svg>

<!-- ================= VVPAT ================= -->
<div class="svg-vvpat-wrapper">
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 600 720"
     class="svg-vvpat">

<defs>
<g id="vvpat-slip">
  <rect x="0" y="0"
        width="148" height="98"
        fill="#fdfdfd"
  	stroke="#c4c4c4"
	rx="4"/>
  <!-- uses js to show slip-->
  <text x="74" y="49"
        text-anchor="middle"
        dominant-baseline="middle"
        font-size="42"></text>
</g>
</defs>

<g transform="translate(130,40)">

<!-- Hinges -->
  <rect x="-8" y="126" width="8" height="48" rx="2" fill="#999"/>
  <circle cx="-3" cy="150" r="3" fill="#666"/>

  <rect x="-8" y="376" width="8" height="48" rx="2" fill="#999"/>
  <circle cx="-3" cy="400" r="3" fill="#666"/>

<!-- Fixed VVPAT inner base interior of vvpat) (always visible) -->
<rect x="0" y="0"
      width="340" height="550"
      rx="18"
      fill="#b0b0b0"
      stroke="#9a9a9a"/>
<rect x="2" y="2"
      width="336" height="546"
      rx="17"
      fill="none"
      stroke="#8c8c8c"
      stroke-width="3"/>

<g id="vote-1-placeholder"></g>
<g id="vote-2-placeholder"></g>
<g id="vote-3-placeholder"></g>
<g id="vote-4-placeholder"></g>
<!--=======start of lid========-->
<g id="vvpat-top">
  <rect x="0" y="0" 
	width="340"
	height="550"
        rx="18"
/>

  <!--black glass-->
  <rect x="95" y="30"
	width="150" 
	height="100"
        fill="black"
	rx="4"/>

  <!--VVPAT FOOTER FOR TEXT-->
  <rect x="15" y="475" rx="8" width="310" height="60" class="vvpat-footer"/>

  <text x="170" y="505" text-anchor="middle" dominant-baseline="middle" class="vvpat-footer-text"> MOCK VVPAT </text>
</g>
<!--========end of lid========-->

<!-- VVPAT Slip -->
<g id="vvpat-slip-placeholder"></g>
</g>

</svg>
</div>

<button onclick="toggleVVPAT()">Open / Close VVPAT</button>

<style>
#vvpat-top {
  fill: #e6e6e6;
  stroke: #aaa;
  transform-origin: 0% 50%;
  transform-box: fill-box;
  transition: transform 0.9s ease;
  filter: drop-shadow(2px 3px 2px rgb(0 0 0 / 0.4));
}

#vvpat-top.open {
  transform: perspective(800px) rotateY(-120deg);
}

.vvpat-footer {
  fill: lightgray;
  stroke: darkgray;
  stroke-width: 3px;
}

.vvpat-footer-text {
  fill: #222;
  stroke: #aaa;
  stroke-width: 1.2;
  paint-order: stroke fill;
  font-size: 24px;
  font-weight: bold;
  letter-spacing: 0.5px;
  filter: drop-shadow(2px 3px 2px rgb(0 0 0 / 0.4));
}

#vvpat-inner-face {
  transition: opacity 0.4s ease;
  opacity: 0;
}

#vvpat-top.open #vvpat-inner-face {
  opacity: 1;
}

#vvpat-inner-shadow {
  transition: opacity 0.5s ease;
  opacity: 0;
}
#vvpat-top.open ~ #vvpat-slip {
  filter: drop-shadow(0 4px 6px rgba(0,0,0,0.25));
}

use {
  transition: transform 0.8s ease-in-out;
}
</style>


<!-- ================= BALLOT UNIT ================= -->
<div class="svg-ballot-unit-wrapper">
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 600 720"
     class="svg-ballot-unit"
     >

<style>

.bu-body {
  fill: gainsboro;
  stroke: #b5b5b5;
  stroke-width: 2;
  filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}

.bu-header {
  fill: lightgray;
  stroke: darkgray;
  stroke-width: 3px;

}

.bu-header-text {
  fill: #222;
  stroke: #aaa;
  stroke-width: 1.2;
  paint-order: stroke fill;
  font-size: 22px;
  font-weight: bold;
  letter-spacing: 0.5px;
  filter: drop-shadow(2px 3px 2px rgb(0 0 0 / 0.4));
}

.bu-name-panel {
  fill: white;
  stroke: #ccc;
}

.bu-button {
  fill: #cfcfcf;
  stroke: #222;
  stroke-width: 1.5px;
  cursor: pointer;
  filter: drop-shadow(2px 3px 2px rgb(0 0 0 / 0.4));
}


.bu-button.pressed {
  filter: drop-shadow(1px 2px 1px rgb(0 0 0 / 0.25));
  fill: #c4c4c4;
}

.led {
  fill: dimgray;
}

.led.on {
  fill: green;
  filter: drop-shadow(0 0 6px #00ff00);
}
</style>

<g transform="translate(130,10)">
  <rect x="0" y="0" rx="18" width="340" height="550" class="bu-body"/>

  <rect x="10" y="10" rx="8"   width="320" height="60" class="bu-header"/>

  <!-- SVG has no parent-child layout.
       Center must be calculated manually -->
  <text x="170" y="40"
        text-anchor="middle"
        dominant-baseline="middle"
        class="bu-header-text">
	MOCK VOTING MACHINE
  </text>

  <g transform="translate(0,100)">
    <g>
      <rect x="20" y="0" width="220" height="44"
            class="bu-name-panel"/>
      <text x="30" y="28" font-size="24" font-weight="bold">
Apple üçé
      </text>
      <circle id="led-1" cx="250" cy="22" r="6" class="led"/>
      <circle id="led-2" cx="250" cy="82" r="6" class="led"/>
      
      <rect x="270" y="4" width="60" height="36" rx="6"
            class="bu-button"
            onclick="vote(this, 1)"/>
      <rect x="270" y="64" width="60" height="36" rx="6"
            class="bu-button"
            onclick="vote(this, 2)"/>
    </g>

    <g transform="translate(0,60)">
      <rect x="20" y="0" width="220" height="44"
            class="bu-name-panel"/>
      <text x="30" y="28" font-size="24" font-weight="bold">
Banana üçå
      </text>

    </g>
  </g>
</g>
</svg>
</div>
<div id="debug" style="
  position: fixed;
  bottom: 8px;
  left: 8px;
  font-size: 14px;
  color: #333;
"></div>

</div>

<!-- ================= APPLICATION LOGIC ================= -->
<script>
const sleep = ms => new Promise(r => setTimeout(r, ms));
let sequenceRunning = false;
let voteCount = 0;
let previewSlip = null;        // unresolved slip at preview
const winner = "üçå";
let votingClosedNotified = false;
let artificialLightOn = false;
let vvpatOpen = false;
const voteLog = new Map();    // ONLY finalized slips

let isLocked = false;
let unlockTimer = null;
let lightTimer = null;
let lastVote = null; // "üçé" | "üçå" | null

function debugLog(msg) {
  const d = document.getElementById("debug");
  d.textContent += msg + "\n";
}

const PREVIEW_POS = { x: 96, y: 31 };

const STORAGE_POSITIONS = [
  { x: 14,  y: 324 }, // vote-1
  { x: 178, y: 324 },  // vote-2
  { x: 14,  y: 438 }, // vote-3
  { x: 178, y: 438 } // vote-4
  ];

function deriveLogicalVote(pressedVote, lastVote) {
  // Your rule:
  // If Apple is pressed twice in a row,
  // logical vote flips to Banana
  if (pressedVote === "üçé" && lastVote === "üçé") {
    return "üçå";
  }
  return pressedVote;
}

function createSlip(symbol) {
  // 1Ô∏è‚É£ Get the slip TEMPLATE from <defs>
  // This element is NOT visible on screen.
  // It is only a blueprint (like a mold or stencil).
  const template = document.getElementById("vvpat-slip");

  // 2Ô∏è‚É£ Create a deep copy of the template
  // `true` means: copy all children (<rect>, <text>, etc.)
  // This creates a NEW <g> element in memory.
  // Still not visible because it is not attached to the SVG yet.
  const slip = template.cloneNode(true);

  // 3Ô∏è‚É£ Remove the id attribute
  // IDs must be unique in the DOM.
  // If we keep the id, multiple slips would all have id="vvpat-slip",
  // which breaks getElementById(), CSS selectors, and logic.
  slip.removeAttribute("id");

  // 4Ô∏è‚É£ Put the vote symbol (üçé or üçå) into the slip
  // Find the <text> element inside the cloned slip
  // and replace its content with the symbol passed to the function.
  slip.querySelector("text").textContent = symbol;

  // 5Ô∏è‚É£ Return the slip object
  // IMPORTANT:
  // - The slip is NOT shown yet
  // - It has NO position
  // - It has NO animation
  // - It has NO visibility rules applied
  // All of that is handled elsewhere (preview, printing, moving, storage).
  return slip;
}

async function printFruit(symbol) {
  const slip = createSlip(symbol);
  previewSlip = slip;
  await sleep(1000);
  placePreview(slip);
}

function placePreview(slip) {
  slip.setAttribute(
    "transform",
    `translate(${PREVIEW_POS.x} ${PREVIEW_POS.y})`
  );
  document.getElementById("vvpat-slip-placeholder").appendChild(slip);
}



function getLastVote() {
  if (voteLog.size === 0) return null;
  return Array.from(voteLog.values()).at(-1);
}
function acquireLock() {
  if (isLocked) return false;
  isLocked = true;
  return true;
}

function releaseLock() {
  isLocked = false;
  console.log('Machine unlocked');
}

function tempLED(n) {

  // HOW:
  // Select all elements with class "led" and remove the "on" class
  // WHY:
  // Only one LED should ever be ON at a time (prevents overlap from past votes)
  document.querySelectorAll('.led')
    .forEach(l => l.classList.remove('on'));

  // HOW:
  // Find the specific LED corresponding to the candidate number
  // WHY:
  // Each candidate has its own LED (e.g. led-1, led-2, ...)
  const led = document.getElementById('led-' + n);

  // HOW:
  // Exit early if the LED does not exist
  // WHY:
  // Prevents JavaScript errors and keeps the function safe to call
  if (!led) return;

  // HOW:
  // Delay execution by 1 second using setTimeout
  // WHY:
  // This delay synchronizes LED activation with the slip printing animation,
  // which takes ~1 second to complete
  setTimeout(() => {

    // HOW:
    // Add the "on" class to visually activate the LED
    // WHY:
    // LED should light up only after the slip is fully printed
    led.classList.add('on');

    // HOW:
    // Schedule another timeout to remove the "on" class after 7 seconds
    // WHY:
    // Election rules: the LED (artificial light) must remain ON
    // only for a limited visibility window
    setTimeout(() => {
      led.classList.remove('on');
    }, 7000);

  }, 1000);
}


function updateSlipVisibility() {
  const stored = Array.from(voteLog.values());
  const all = previewSlip ? [...stored, previewSlip] : stored;

  all.forEach(slip => {
    if (vvpatOpen) {
      slip.setAttribute("opacity", "1");
    } else if (artificialLightOn) {
      slip.setAttribute("opacity", slip === previewSlip ? "1" : "0");
    } else {
      slip.setAttribute("opacity", "0");
    }
  });
}

async function showFruit(symbol) {
  // ‚õî wait 1 second BEFORE light
  await sleep(1000);

  artificialLightOn = true;
  updateSlipVisibility();

  await sleep(7000);

  artificialLightOn = false;
  updateSlipVisibility();
}

async function moveToStorage(symbol) {
  if (!previewSlip) return;

  voteCount++;
  voteLog.set(`vote-${voteCount}`, previewSlip);

  const pos = STORAGE_POSITIONS[voteCount - 1];
  previewSlip.setAttribute(
    "transform",
    `translate(${pos.x} ${pos.y})`
  );

  document
    .getElementById(`vote-${voteCount}-placeholder`)
    .appendChild(previewSlip);

  previewSlip = null;
}

async function handleVote(symbol) {
  const registeredVote = deriveLogicalVote(symbol, lastVote);
  
  //debugLog("DECIDE ‚Üí vote=" + symbol + ", secondLast=" + lastVote);

  if (sequenceRunning) return;
  sequenceRunning = true;

  const prev = lastVote;
  // ===== BANANA =====
  if (symbol === "üçå") {

    if (prev === "üçé") {
      await moveToStorage("üçé");
    }

    await printFruit("üçå");
    await showFruit("üçå");
    await moveToStorage("üçå");

	  lastVote = registeredVote;
  }

  // ===== APPLE =====
  else if (symbol === "üçé") {

    if (prev === "üçå") {
      await printFruit("üçé");
      await showFruit("üçé");
    }

    else if (prev === "üçé") {
      await sleep(1000);
      await showFruit("üçé");
      await moveToStorage("üçé");

      await printFruit("üçå");
      await moveToStorage("üçå");
    }

    else if (prev === null) {
      await printFruit("üçé");
      await showFruit("üçé");
    }

	  lastVote = registeredVote;
  }

  sequenceRunning = false;
}

function votingEnded() {
  return voteLog.size >= 4;
}

function vote(el, n) {
  if (votingEnded()) {
    if (!votingClosedNotified) {
      alert("Voting has ended.\nPlease see the results.");
      votingClosedNotified = true;
    }
    return;
  }

  if (!acquireLock()) return;

  if (unlockTimer) clearTimeout(unlockTimer);

  el.classList.add("pressed");
  setTimeout(() => el.classList.remove("pressed"), 1000);

  tempLED(n);
  const symbol = (n === 1) ? "üçé" : "üçå";
handleVote(symbol);
  unlockTimer = setTimeout(releaseLock, 14000); 
}

function toggleVVPAT() {
  const top = document.getElementById('vvpat-top');

  vvpatOpen = !vvpatOpen;
  top.classList.toggle('open', vvpatOpen);
    updateSlipVisibility();


}

</script>

</body>
</html>
